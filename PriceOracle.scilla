scilla_version 0

import IntUtils

library Oracle
  
  let uint128_zero = Uint128 0
  let one_msg = 
    fun (msg : Message) => 
    let nil_msg = Nil {Message} in
      Cons {Message} msg nil_msg
      
  type Error =
    | CodeNotOwner
    | CannotDecodeBNum
    | OraclePriceToOld
  
  let make_error =
    fun (result : Error) =>
      let result_code = 
        match result with
          | CodeNotOwner              => Int32 -301
          | CannotDecodeBNum          => Int32 -302
          | OraclePriceToOld          => Int32 -303
        end
      in
      { _exception : "Error"; code : result_code }
  
  let decode_bnum = 
    fun (some_value: Option BNum) =>
      match some_value with 
        | Some value => value
        | None => BNum 0
      end
      
  let decode_value = 
    fun (some_value: Option Uint128) =>
      match some_value with 
        | Some value => value
        | None => uint128_zero
      end
      
      
contract PriceOracle
(init_owner: ByStr20)

(*The price is stored in form of cents per million collateral*)
field priceCollateral: Map ByStr20 Uint128 = Emp ByStr20 Uint128
field blockUpdatedAt: Map ByStr20 BNum = Emp ByStr20 BNum
field owner: ByStr20 = init_owner
field acceptableBlockGapForPrices: Uint128 = Uint128 150
  
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsOwner(address: ByStr20)
  oracle_owner <- owner;
  is_owner = builtin eq oracle_owner address;
  match is_owner with
  | True =>
  | False =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure isNotZero(some_value: Option Uint128)
  match some_value with
    | Some value =>
    | None =>
      err = CannotDecodeBNum;
      ThrowError err
  end
end

transition changeOwner(newOwner: ByStr20)
  IsOwner _sender;
  owner := newOwner
end


transition updatePrice(collateralAddress: ByStr20, price: Uint128)
  IsOwner _sender;
  priceCollateral[collateralAddress] := price;
  currentBlock <- & BLOCKNUMBER;
  blockUpdatedAt[collateralAddress] := currentBlock
end

transition GetPrice(collateral: ByStr20)
  some_price <- priceCollateral[collateral];
  isNotZero some_price;
  price = decode_value some_price;
  currentBlock <- & BLOCKNUMBER;
  lastUpdatedBlock <- blockUpdatedAt[collateral];
  lub = decode_bnum lastUpdatedBlock;
  
  blockDiff = builtin bsub currentBlock lub;
  some_diff = builtin to_uint128 blockDiff;
  diff = decode_value some_diff;
  
  abgp <- acceptableBlockGapForPrices;
  
  is_diff_to_big = builtin lt abgp diff;
  
  match is_diff_to_big with
    | False =>
      msg = {_tag: "priceOracleCallback"; _recipient: _sender; _amount: Uint128 0; price: price};
      msgs = one_msg msg;
      send msgs
    | True =>
      err = OraclePriceToOld;
      ThrowError err
  end
end
